# -*- coding: utf-8 -*-
"""Project_Phase2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fetKbU5YkmMpMKUuJ-tlPZosSmF8BMYZ

Upload the Dataset
"""

from google.colab import files
uploaded = files.upload()

"""Load the Dataset"""

import pandas as pd
# Read the dataset
df = pd.read_csv('googl_data_2020_2025.csv', sep=';')

"""Data Exploration"""

# Display first few rows
df.head()

# Shape of the dataset
print("Shape:", df.shape)
# Column names
print("Columns:", df.columns.tolist())
# Data types and non-null values
df.info()
# Summary statistics for numeric features
df.describe()

"""Check for Missing Values and Duplicates"""

# Check for missing values
print(df.isnull().sum())
# Check for duplicates
print("Duplicate rows:", df.duplicated().sum())

"""Visualize a Few Features"""

# Visualizing the stock's closing price with annotations
plt.figure(figsize=(12, 6))
plt.plot(stock_data['Close'], label=f'{stock_ticker} Close Price', color='blue')
plt.title(f"{stock_ticker} Stock Price with Annotations")
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.legend(loc='best')

# Mark a few key events, for instance, a notable price drop or rise (customize this as needed)
# Use index-based access to select a date from stock_data's DateTime index
date_of_interest = pd.Timestamp('2021-01-01')  # Specify the date you want to annotate
if date_of_interest in stock_data.index:
    plt.annotate('Price Spike',
                 xy=(date_of_interest, stock_data.loc[date_of_interest, 'Close']),
                 xytext=(pd.Timestamp('2020-06-01'), stock_data.loc[pd.Timestamp('2020-06-01'), 'Close'] + 10),
                 arrowprops=dict(facecolor='red', shrink=0.05))

plt.grid(True)
plt.show()

"""Identify Target and Features"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Fetch the stock data using Yahoo Finance (you can replace 'AAPL' with any stock ticker)
stock_ticker = 'AAPL'  # Apple as an example
start_date = '2020-01-01'
end_date = '2025-01-01'

# Download stock data from Yahoo Finance
stock_data = yf.download(stock_ticker, start=start_date, end=end_date)

# Display the first few rows of the stock data
print(stock_data.head())

# --- Feature Engineering ---

# 1. Calculate Daily Returns (percentage change)
stock_data['Daily_Return'] = stock_data['Close'].pct_change()

# 2. Moving Averages (50-day and 200-day)
stock_data['50_MA'] = stock_data['Close'].rolling(window=50).mean()
stock_data['200_MA'] = stock_data['Close'].rolling(window=200).mean()

# 3. Volatility (Rolling standard deviation)
stock_data['Volatility'] = stock_data['Close'].rolling(window=50).std()

# 4. Trading Volume (can be used as a feature)
stock_data['Volume'] = stock_data['Volume']

# 5. Lag Features (Previous day's closing price, etc.)
stock_data['Prev_Close'] = stock_data['Close'].shift(1)

# 6. Lag Returns (Previous day's returns)
stock_data['Prev_Return'] = stock_data['Daily_Return'].shift(1)

# --- Define Target Variable ---
# Predicting the next day's closing price
stock_data['Target'] = stock_data['Close'].shift(-1)

# Drop rows with missing values (e.g., from shifting data)
stock_data.dropna(inplace=True)

# Display the first few rows of the dataset with new features
print(stock_data.head())

# --- Visualizations (Optional) ---
# Visualizing the features like moving averages and closing price
plt.figure(figsize=(12, 6))
plt.plot(stock_data['Close'], label='Stock Price (Close)', color='blue', linewidth=1)
plt.plot(stock_data['50_MA'], label='50-day Moving Average', color='orange', linestyle='--')
plt.plot(stock_data['200_MA'], label='200-day Moving Average', color='green', linestyle='--')
plt.title(f"{stock_ticker} Stock Price and Moving Averages")
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.legend(loc='best')
plt.grid(True)
plt.show()

# Visualizing the stock volatility
plt.figure(figsize=(12, 6))
plt.plot(stock_data['Volatility'], label='50-day Rolling Volatility', color='red')
plt.title(f"{stock_ticker} Volatility (50-day Rolling Std Dev)")
plt.xlabel('Date')
plt.ylabel('Volatility')
plt.legend(loc='best')
plt.grid(True)
plt.show()

# --- Conclusion ---
# The target is the 'Target' column, which represents the next day's closing price.
# The features include:
# - Daily returns
# - Moving averages (50-day and 200-day)
# - Volatility (50-day rolling standard deviation)
# - Trading volume
# - Lag features (previous day's close and return)

"""Convert Categorical Columns to Numerical"""

import pandas as pd
import yfinance as yf
from sklearn.preprocessing import LabelEncoder

# Fetch the stock data using Yahoo Finance (you can replace 'AAPL' with any stock ticker)
stock_ticker = 'AAPL'  # Apple as an example
start_date = '2020-01-01'
end_date = '2025-01-01'

# Download stock data from Yahoo Finance
stock_data = yf.download(stock_ticker, start=start_date, end=end_date)

# Suppose we have some categorical data like 'Sector' or 'Market' (for illustration)
# For the sake of the example, let's create a mock 'Sector' column
# In real scenarios, you'd have such columns in your dataset.
stock_data['Sector'] = ['Tech', 'Tech', 'Health', 'Tech', 'Health', 'Finance', 'Tech', 'Finance', 'Health', 'Tech']

# Display the first few rows of the stock data with 'Sector' column
print("Original Data with Categorical 'Sector':")
print(stock_data.head())

# --- 1. Label Encoding: Converting 'Sector' to numerical labels ---
label_encoder = LabelEncoder()

# Apply label encoding on the 'Sector' column
stock_data['Sector_Label'] = label_encoder.fit_transform(stock_data['Sector'])

# Display the updated DataFrame with Label Encoded column
print("\nAfter Label Encoding 'Sector':")
print(stock_data[['Sector', 'Sector_Label']].head())

# --- 2. One-Hot Encoding: Creating binary columns for each category in 'Sector' ---
stock_data_encoded = pd.get_dummies(stock_data, columns=['Sector'], drop_first=False)

# Display the updated DataFrame with One-Hot Encoded columns
print("\nAfter One-Hot Encoding 'Sector':")
print(stock_data_encoded.head())

"""One-Hot Encoding"""

import pandas as pd
import yfinance as yf

# Fetch stock data using Yahoo Finance (you can replace 'AAPL' with any stock ticker)
stock_ticker = 'AAPL'  # Example: Apple
start_date = '2020-01-01'
end_date = '2025-01-01'

# Download stock data from Yahoo Finance
stock_data = yf.download(stock_ticker, start=start_date, end=end_date)

# For the sake of this example, let's assume 'Sector' is a column that contains categorical data
# We'll mock this data for illustration purposes
# In practice, you might get this from another source or API.
stock_data['Sector'] = ['Tech', 'Tech', 'Health', 'Tech', 'Health', 'Finance', 'Tech', 'Finance', 'Health', 'Tech']

# Let's assume you also have 'Stock Ticker' as a categorical column
stock_data['Stock Ticker'] = stock_ticker  # In this example, it's just 'AAPL'

# Display original stock data
print("Original Data with Categorical Columns:")
print(stock_data.head())

# --- One-Hot Encoding: Creating binary columns for each category ---
# Using pd.get_dummies to perform one-hot encoding on the 'Sector' and 'Stock Ticker' columns
stock_data_encoded = pd.get_dummies(stock_data, columns=['Sector', 'Stock Ticker'], drop_first=False)

# Display the DataFrame after one-hot encoding
print("\nData After One-Hot Encoding:")
print(stock_data_encoded.head())

"""Feature Scaling"""

import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Step 1: Fetch Stock Data from Yahoo Finance
ticker = 'AAPL'  # Example: Apple stock, you can change this to any stock ticker symbol
start_date = '2020-01-01'  # Start date for the time series data
end_date = '2025-01-01'    # End date for the time series data

data = yf.download(ticker, start=start_date, end=end_date)

# Step 2: Feature Engineering (Creating new features like moving averages and returns)
data['7_day_MA'] = data['Close'].rolling(window=7).mean()  # 7-day moving average
data['30_day_MA'] = data['Close'].rolling(window=30).mean()  # 30-day moving average
data['Daily_Return'] = data['Close'].pct_change()  # Daily returns (percentage change)

# Step 3: Drop missing values generated by moving averages and returns
data.dropna(inplace=True)

# Step 4: Select features and target variable
features = ['Open', 'High', 'Low', 'Close', 'Volume', '7_day_MA', '30_day_MA', 'Daily_Return']
target = 'Close'  # Predicting the closing price

# Extract feature set (X) and target (y)
X = data[features]
y = data[target]

# Step 5: Feature Scaling using MinMaxScaler (or StandardScaler)
scaler = MinMaxScaler()  # Normalize

"""Train-Test Split"""

import pandas as pd
import yfinance as yf

# Load historical stock data (you can change the ticker)
stock_ticker = 'AAPL'
data = yf.download(stock_ticker, start='2015-01-01', end='2024-12-31')

# Optional: keep only relevant features
features = ['Open', 'High', 'Low', 'Close', 'Volume']
data = data[features]

# Drop rows with missing values (if any)
data.dropna(inplace=True)

# Define train-test split size (e.g., 80% train, 20% test)
train_size = int(len(data) * 0.8)

# Split the data chronologically
train_data = data[:train_size]
test_data = data[train_size:]

# Print info
print("Total samples:", len(data))
print("Training samples:", len(train_data))
print("Testing samples:", len(test_data))
print("\nTrain data preview:")
print(train_data.tail())
print("\nTest data preview:")
print(test_data.head())

"""Model Building"""

import yfinance as yf
import matplotlib.pyplot as plt

# Step 1: Load stock data
ticker = 'AAPL'
start = '2020-01-01'
end = '2025-01-01'
df = yf.download(ticker, start=start, end=end)

# Step 2: Use only 'Close' price
df = df[['Close']].copy()

# Step 3: Create prediction using 5-day moving average
df['Predicted'] = df['Close'].rolling(window=5).mean()

# Step 4: Drop NaN rows (first 4 will be NaN due to rolling)
df.dropna(inplace=True)

# Step 5: Plot actual vs predicted (no model.fit used)
plt.figure(figsize=(10, 6))
plt.plot(df['Close'], label='Actual Price', color='blue')
plt.plot(df['Predicted'], label='5-Day Moving Avg Prediction', color='orange')
plt.title(f'{ticker} Stock Price Prediction using Moving Average')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Evaluation"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Assume these are available from your model
# Replace with your actual prediction and test values
# y_test: actual values
# y_pred: predicted values

# Example dummy values (replace with real ones)
# y_test = np.array([...])
# y_pred = np.array([...])

# --- Evaluation Metrics ---
def evaluate_model(y_test, y_pred):
    mae = mean_absolute_error(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_test, y_pred)

    print("📊 Model Evaluation Results:")
    print(f"✅ MAE  (Mean Absolute Error):      {mae:.4f}")
    print(f"✅ MSE  (Mean Squared Error):       {mse:.4f}")
    print(f"✅ RMSE (Root Mean Squared Error):  {rmse:.4f}")
    print(f"✅ R² Score:                        {r2:.4f}")

# Example usage
# evaluate_model(y_test, y_pred)

"""Make Predictions from New Input"""

import numpy as np

# Step 1: Input the last 5 stock prices from the user
user_input = []
print("Please input the last 5 stock prices:")

for i in range(5):
    price = float(input(f"Day {i+1} closing price: "))  # Take user input for each day's closing price
    user_input.append(price)

# Step 2: Calculate the Moving Average of the last 5 stock prices
moving_average = np.mean(user_input)

# Step 3: Predict the next day's stock price using the Moving Average
predicted_price = moving_average

# Step 4: Output the predicted price
print(f"\nPredicted next day's stock price using Moving Average: {predicted_price:.2f}")

"""Convert to DataFrame and Encode"""

import yfinance as yf
import pandas as pd

# Step 1: Download stock data (e.g., Apple stock data from Yahoo Finance)
ticker = 'AAPL'  # You can change this to any stock symbol (e.g., 'GOOGL', 'TSLA')
start = '2020-01-01'
end = '2025-01-01'
df = yf.download(ticker, start=start, end=end)

# Step 2: Convert the stock data to a pandas DataFrame
df = df[['Close']]  # Use only 'Close' price for prediction

# Display the first 5 rows to show the DataFrame
print("\nStock Data as DataFrame:")
print(df.head())

# Step 3: Normalize the stock prices using min-max normalization
min_price = df['Close'].min()  # Minimum closing price
max_price = df['Close'].max()  # Maximum closing price

# Apply the min-max normalization formula
df['Normalized_Close'] = (df['Close'] - min_price) / (max_price - min_price)

# Display the normalized data
print("\nNormalized Stock Data:")
print(df.head())

# Now the DataFrame contains the original 'Close' prices and the 'Normalized_Close' prices.

"""Predict the Final Grade"""

from sklearn.linear_model import LinearRegression
import numpy as np

# Step 1: Sample data — last 5 days of stock prices (can be hardcoded or entered by user)
# You can change these values or ask user input
last_prices = [150, 152, 153.5, 155, 157]  # Simulated "test scores" leading to final grade

# Step 2: Prepare data for model
# X = day indices (0 to len-1), y = stock prices
X = np.array(range(len(last_prices))).reshape(-1, 1)
y = np.array(last_prices)

# Step 3: Train a simple Linear Regression model
model = LinearRegression()
model.fit(X, y)

# Step 4: Predict the "final grade" — i.e., the next day's stock price
next_day_index = len(last_prices)  # Predict for the next day
predicted_price = model.predict([[next_day_index]])

# Step 5: Show result
print(f"Predicted final stock price (like final grade): {predicted_price[0]:.2f}")

"""Deployment-Building an Interactive App"""

from flask import Flask, render_template, request
import numpy as np
from sklearn.linear_model import LinearRegression

app = Flask(__name__)

# Step 1: Create the home route to render the HTML form
@app.route('/')
def home():
    return render_template('index.html')  # Render the HTML page

# Step 2: Create the predict route to handle the form submission
@app.route('/predict', methods=['POST'])
def predict():
    try:
        # Step 3: Get the user input (last 5 stock prices)
        prices = [float(request.form[f'price{i}']) for i in range(1, 6)]

        if len(prices) != 5 or any(price <= 0 for price in prices):
            raise ValueError("Invalid input, please enter positive numbers")

        # Step 4: Prepare data for Linear Regression model
        X = np.array(range(len(prices))).reshape(-1, 1)  # Day indices (0, 1, 2, 3, 4)
        y = np.array(prices)

        # Step 5: Train the model
        model = LinearRegression()
        model.fit(X, y)

        # Step 6: Predict the next day's price
        next_day = np.array([[len(prices)]])  # Predict for the next day (day 5)
        predicted_price = model.predict(next_day)[0]

        # Step 7: Render the result on the webpage
        return render_template('index.html', prediction_text=f"Predicted Next Day Price: ${predicted_price:.2f}")

    except Exception as e:
        return render_template('index.html', error_message=str(e))

if __name__ == "__main__":
    app.run(debug=True)

"""Create a Prediction Function"""

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import pandas as pd

# Sample dataset
data = {
    'square_feet': [1000, 1500, 2000, 2500, 3000],
    'price': [200000, 250000, 300000, 350000, 400000]
}

df = pd.DataFrame(data)

# Features and target
X = df[['square_feet']]
y = df['price']

# Split into training/testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train the model
model = LinearRegression()
model.fit(X_train, y_train)

# Prediction function
def predict_price(square_feet):
    return model.predict([[square_feet]])[0]

# Example prediction
predicted = predict_price(1800)
print(f"Predicted price for 1800 sqft: ${predicted:.2f}")